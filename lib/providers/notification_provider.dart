import 'dart:async';
import 'package:flutter/material.dart';
import '../models/notification_model.dart';
import '../models/user_model.dart';
import '../services/firebase_database_service.dart';
import 'auth_provider.dart';

class NotificationProvider with ChangeNotifier {
  final FirebaseDatabaseService _dbService = FirebaseDatabaseService();
  List<NotificationModel> _notifications = [];
  bool _isLoading = false;
  StreamSubscription? _notificationSubscription;

  List<NotificationModel> get notifications => _notifications;
  bool get isLoading => _isLoading;

  int get unreadCount => _notifications.where((n) => !n.isRead).length;

  void init(AuthProvider authProvider) {
    if (authProvider.currentUser != null) {
      _listenToNotifications(authProvider.currentUser!.id);
    } else {
      _notificationSubscription?.cancel();
      _notifications = [];
      notifyListeners();
    }
  }

  void _listenToNotifications(String userId) {
    _isLoading = true;
    notifyListeners();

    _notificationSubscription?.cancel();
    _notificationSubscription = _dbService
        .getUserNotifications(userId)
        .onValue
        .listen((event) {
          final data = event.snapshot.value;
          if (data == null) {
            _notifications = [];
          } else {
            final Map<dynamic, dynamic> map = data as Map<dynamic, dynamic>;
            _notifications = map.entries.map((e) {
              final notif = Map<String, dynamic>.from(
                e.value as Map<dynamic, dynamic>,
              );
              notif['id'] = e.key; // Ensure ID is set
              return NotificationModel.fromJson(notif);
            }).toList();

            // Sort by timestamp descending (newest first)
            _notifications.sort((a, b) => b.timestamp.compareTo(a.timestamp));
          }
          _isLoading = false;
          notifyListeners();
        });
  }

  Future<void> markAsRead(String notificationId) async {
    // Optimistic update
    final index = _notifications.indexWhere((n) => n.id == notificationId);
    if (index != -1) {
      final oldNotif = _notifications[index];
      _notifications[index] = NotificationModel(
        id: oldNotif.id,
        userId: oldNotif.userId,
        title: oldNotif.title,
        message: oldNotif.message,
        timestamp: oldNotif.timestamp,
        isRead: true,
        type: oldNotif.type,
        relatedId: oldNotif.relatedId,
      );
      notifyListeners();
    }

    await _dbService.markNotificationAsRead(notificationId);
  }

  Future<void> sendNotification({
    required String userId,
    required String title,
    required String message,
    required String type,
    String? relatedId,
  }) async {
    final notification = NotificationModel(
      id: '', // Generated by DB
      userId: userId,
      title: title,
      message: message,
      timestamp: DateTime.now(),
      type: type,
      relatedId: relatedId,
    );

    await _dbService.createNotification(notification.toJson());
  }

  @override
  void dispose() {
    _notificationSubscription?.cancel();
    super.dispose();
  }
}
